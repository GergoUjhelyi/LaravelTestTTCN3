module HTTP_Tests {

import from HTTPmsg_PortType all;
import from HTTPmsg_Types all;
import from HTTP_Test_Types all;
import from UsageStat_Type all;

//Default server parameters
modulepar charstring HttpServerHost := "localhost";
modulepar integer HttpServerPort := 8000;
modulepar boolean HttpServerUseSSL := false;

type component HTTP_client {
  port HTTPmsg_PT client_port;
};

/***************************************
** @desc Test the main page which is a generated HTML page **
** @verdict pass if the server is running and have a main page **
**************************************/ 
testcase tc_laravel_index_test() runs on HTTP_client {
  var Connect v_connection_message := { hostname := HttpServerHost, portnumber:= HttpServerPort, use_ssl:= HttpServerUseSSL };
  var Close v_close_message := { client_id:= omit };
  var HTTPMessage v_HTTP_response;

  //Map to server
  map(self:client_port, system:client_port);

  //Send HTTP connection
  client_port.send(v_connection_message);

  timer T_timer := 4.0;

  //Send generated HTTP request
  client_port.send(c_http_get_main_page);

  T_timer.start;

  alt {
    //Receive a HTTP message
    [] client_port.receive(HTTPMessage:?) -> value v_HTTP_response {
      if (match(v_HTTP_response, recv_ok_response)) {
        setverdict(pass, "Received HTTP OK/200 response! Received: ", v_HTTP_response);
      } else {
        setverdict(fail, "Received wrong response! Received: ", v_HTTP_response);
      }
      client_port.send(v_close_message);
      T_timer.stop;
    }
    //Receive a Half_Close response
    [] client_port.receive(any_half_close) {
      client_port.send(v_close_message);
      T_timer.stop;
      setverdict(fail);
    }
    //Receive something else
    [] client_port.receive {
      client_port.send(v_close_message);
      T_timer.stop;
      setverdict(fail);
    }
    //Receive nothing until the end of the timer T_timer
    [] T_timer.timeout {
      setverdict(fail);
    }
  };
  //Unmap from server
  unmap(self:client_port, system:client_port);
}

testcase tc_laravel_get_all_json() runs on HTTP_client {
  var Connect v_connection_message := { hostname := HttpServerHost, portnumber:= HttpServerPort, use_ssl:= HttpServerUseSSL };
  var Close close_message := { client_id:= omit };
  var HTTPMessage  v_HTTP_response;
  var octetstring v_body;
  var charstring vl_char_body;

  //Map to server
  map(self:client_port, system:client_port);

  //Send HTTP connection
  client_port.send(v_connection_message);

  

  timer T_timer := 4.0;

  //Send generated HTTP request
  client_port.send(c_http_get_all_usage_stats);

  if (T_timer.running) {
    T_timer.stop;
  }

  T_timer.start;

  alt {
    //Receive a HTTP response
    [] client_port.receive(HTTPMessage:?) -> value v_HTTP_response {
      if (ischosen(v_HTTP_response.response_binary)) {
        v_body:=v_HTTP_response.response_binary.body;
        
        log("v_body", v_body);
        log("encodingtype", get_stringencoding(v_body));
      } else if (ischosen(v_HTTP_response.response)) {
        vl_char_body:= v_HTTP_response.response.body;
        log("vl_char_body", vl_char_body);
        var Usage_Stat_Response_Array v_JSON_PDU := ef_dec_usage_arr_JSON(char2oct(vl_char_body));
        log_usage_stat_response_array(v_JSON_PDU);
        //TODO: match with a template
        if (lengthof(v_JSON_PDU) > 0) {
          setverdict(pass);
        } else {
          setverdict(fail);
        }
      }
    }
    //Receive a Half_Close response
    [] client_port.receive(any_half_close) {
      client_port.send(close_message);
      T_timer.stop;
      setverdict(fail);
    }
    //Receive something else
    [] client_port.receive {
      client_port.send(close_message);
      T_timer.stop;
      setverdict(fail);
    }
    [] T_timer.timeout {
      setverdict(fail);
    }
  };
  //Unmap from server
  unmap(self:client_port, system:client_port);
}

}
